{"version":3,"sources":["../../../../node_modules/%40swc/helpers/cjs/_interop_require_wildcard.cjs","../../../../node_modules/next/dist/client/app-dir/link.js/__nextjs-internal-proxy.cjs","../../../../node_modules/next/src/client/app-dir/link.tsx","../../../../node_modules/next/src/client/app-dir/link.react-server.tsx","../../../../src/lib/supabase/queries.ts"],"sourcesContent":["\"use strict\";\n\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) return obj;\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") return { default: obj };\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n\n    if (cache && cache.has(obj)) return cache.get(obj);\n\n    var newObj = { __proto__: null };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);\n            else newObj[key] = obj[key];\n        }\n    }\n\n    newObj.default = obj;\n\n    if (cache) cache.set(obj, newObj);\n\n    return newObj;\n}\nexports._ = _interop_require_wildcard;\n","// This file is generated by next-core EcmascriptClientReferenceModule.\nconst { createClientModuleProxy } = require(\"react-server-dom-turbopack/server\");\n\n__turbopack_context__.n(createClientModuleProxy(\"[project]/node_modules/next/dist/client/app-dir/link.js\"));\n","'use client'\n\nimport React, { createContext, useContext, useOptimistic, useRef } from 'react'\nimport type { UrlObject } from 'url'\nimport { formatUrl } from '../../shared/lib/router/utils/format-url'\nimport { AppRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useMergedRef } from '../use-merged-ref'\nimport { isAbsoluteUrl } from '../../shared/lib/utils'\nimport { addBasePath } from '../add-base-path'\nimport { warnOnce } from '../../shared/lib/utils/warn-once'\nimport type { PENDING_LINK_STATUS } from '../components/links'\nimport {\n  IDLE_LINK_STATUS,\n  mountLinkInstance,\n  onNavigationIntent,\n  unmountLinkForCurrentNavigation,\n  unmountPrefetchableInstance,\n  type LinkInstance,\n} from '../components/links'\nimport { isLocalURL } from '../../shared/lib/router/utils/is-local-url'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from '../components/segment-cache/types'\nimport { errorOnce } from '../../shared/lib/utils/error-once'\n\ntype Url = string | UrlObject\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]\n\ntype OnNavigateEventHandler = (event: { preventDefault: () => void }) => void\n\ntype InternalLinkProps = {\n  /**\n   * **Required**. The path or URL to navigate to. It can also be an object (similar to `URL`).\n   *\n   * @example\n   * ```tsx\n   * // Navigate to /dashboard:\n   * <Link href=\"/dashboard\">Dashboard</Link>\n   *\n   * // Navigate to /about?name=test:\n   * <Link href={{ pathname: '/about', query: { name: 'test' } }}>\n   *   About\n   * </Link>\n   * ```\n   *\n   * @remarks\n   * - For external URLs, use a fully qualified URL such as `https://...`.\n   * - In the App Router, dynamic routes must not include bracketed segments in `href`.\n   */\n  href: Url\n\n  /**\n   * @deprecated v10.0.0: `href` props pointing to a dynamic route are\n   * automatically resolved and no longer require the `as` prop.\n   */\n  as?: Url\n\n  /**\n   * Replace the current `history` state instead of adding a new URL into the stack.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/about\" replace>\n   *   About (replaces the history state)\n   * </Link>\n   * ```\n   */\n  replace?: boolean\n\n  /**\n   * Whether to override the default scroll behavior. If `true`, Next.js attempts to maintain\n   * the scroll position if the newly navigated page is still visible. If not, it scrolls to the top.\n   *\n   * If `false`, Next.js will not modify the scroll behavior at all.\n   *\n   * @defaultValue `true`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" scroll={false}>\n   *   No auto scroll\n   * </Link>\n   * ```\n   */\n  scroll?: boolean\n\n  /**\n   * Update the path of the current page without rerunning data fetching methods\n   * like `getStaticProps`, `getServerSideProps`, or `getInitialProps`.\n   *\n   * @remarks\n   * `shallow` only applies to the Pages Router. For the App Router, see the\n   * [following documentation](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#using-the-native-history-api).\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/blog\" shallow>\n   *   Shallow navigation\n   * </Link>\n   * ```\n   */\n  shallow?: boolean\n\n  /**\n   * Forces `Link` to pass its `href` to the child component. Useful if the child is a custom\n   * component that wraps an `<a>` tag, or if you're using certain styling libraries.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" passHref legacyBehavior>\n   *   <MyStyledAnchor>Dashboard</MyStyledAnchor>\n   * </Link>\n   * ```\n   */\n  passHref?: boolean\n\n  /**\n   * Prefetch the page in the background.\n   * Any `<Link />` that is in the viewport (initially or through scroll) will be prefetched.\n   * Prefetch can be disabled by passing `prefetch={false}`.\n   *\n   * @remarks\n   * Prefetching is only enabled in production.\n   *\n   * - In the **App Router**:\n   *   - `\"auto\"`, `null`, `undefined` (default): Prefetch behavior depends on static vs dynamic routes:\n   *     - Static routes: fully prefetched\n   *     - Dynamic routes: partial prefetch to the nearest segment with a `loading.js`\n   *   - `true`: Always prefetch the full route and data.\n   *   - `false`: Disable prefetching on both viewport and hover.\n   * - In the **Pages Router**:\n   *   - `true` (default): Prefetches the route and data in the background on viewport or hover.\n   *   - `false`: Prefetch only on hover, not on viewport.\n   *\n   * @defaultValue `true` (Pages Router) or `null` (App Router)\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" prefetch={false}>\n   *   Dashboard\n   * </Link>\n   * ```\n   */\n  prefetch?: boolean | 'auto' | null\n\n  /**\n   * (unstable) Switch to a full prefetch on hover. Effectively the same as\n   * updating the prefetch prop to `true` in a mouse event.\n   */\n  unstable_dynamicOnHover?: boolean\n\n  /**\n   * The active locale is automatically prepended in the Pages Router. `locale` allows for providing\n   * a different locale, or can be set to `false` to opt out of automatic locale behavior.\n   *\n   * @remarks\n   * Note: locale only applies in the Pages Router and is ignored in the App Router.\n   *\n   * @example\n   * ```tsx\n   * // Use the 'fr' locale:\n   * <Link href=\"/about\" locale=\"fr\">\n   *   About (French)\n   * </Link>\n   *\n   * // Disable locale prefix:\n   * <Link href=\"/about\" locale={false}>\n   *   About (no locale prefix)\n   * </Link>\n   * ```\n   */\n  locale?: string | false\n\n  /**\n   * Enable legacy link behavior.\n   *\n   * @deprecated This will be removed in a future version\n   * @defaultValue `false`\n   * @see https://github.com/vercel/next.js/commit/489e65ed98544e69b0afd7e0cfc3f9f6c2b803b7\n   */\n  legacyBehavior?: boolean\n\n  /**\n   * Optional event handler for when the mouse pointer is moved onto the `<Link>`.\n   */\n  onMouseEnter?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is touched.\n   */\n  onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is clicked.\n   */\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is navigated.\n   */\n  onNavigate?: OnNavigateEventHandler\n}\n\n// TODO-APP: Include the full set of Anchor props\n// adding this to the publicly exported type currently breaks existing apps\n\n// `RouteInferType` is a stub here to avoid breaking `typedRoutes` when the type\n// isn't generated yet. It will be replaced when type generation runs.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type LinkProps<RouteInferType = any> = InternalLinkProps\ntype LinkPropsRequired = RequiredKeys<LinkProps>\ntype LinkPropsOptional = OptionalKeys<Omit<InternalLinkProps, 'locale'>>\n\nfunction isModifiedEvent(event: React.MouseEvent): boolean {\n  const eventTarget = event.currentTarget as HTMLAnchorElement | SVGAElement\n  const target = eventTarget.getAttribute('target')\n  return (\n    (target && target !== '_self') ||\n    event.metaKey ||\n    event.ctrlKey ||\n    event.shiftKey ||\n    event.altKey || // triggers resource download\n    (event.nativeEvent && event.nativeEvent.which === 2)\n  )\n}\n\nfunction linkClicked(\n  e: React.MouseEvent,\n  href: string,\n  as: string,\n  linkInstanceRef: React.RefObject<LinkInstance | null>,\n  replace?: boolean,\n  scroll?: boolean,\n  onNavigate?: OnNavigateEventHandler\n): void {\n  if (typeof window !== 'undefined') {\n    const { nodeName } = e.currentTarget\n\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A'\n    if (\n      (isAnchorNodeName && isModifiedEvent(e)) ||\n      e.currentTarget.hasAttribute('download')\n    ) {\n      // ignore click for browser’s default behavior\n      return\n    }\n\n    if (!isLocalURL(href)) {\n      if (replace) {\n        // browser default behavior does not replace the history state\n        // so we need to do it manually\n        e.preventDefault()\n        location.replace(href)\n      }\n\n      // ignore click for browser’s default behavior\n      return\n    }\n\n    e.preventDefault()\n\n    if (onNavigate) {\n      let isDefaultPrevented = false\n\n      onNavigate({\n        preventDefault: () => {\n          isDefaultPrevented = true\n        },\n      })\n\n      if (isDefaultPrevented) {\n        return\n      }\n    }\n\n    const { dispatchNavigateAction } =\n      require('../components/app-router-instance') as typeof import('../components/app-router-instance')\n\n    React.startTransition(() => {\n      dispatchNavigateAction(\n        as || href,\n        replace ? 'replace' : 'push',\n        scroll ?? true,\n        linkInstanceRef.current\n      )\n    })\n  }\n}\n\nfunction formatStringOrUrl(urlObjOrString: UrlObject | string): string {\n  if (typeof urlObjOrString === 'string') {\n    return urlObjOrString\n  }\n\n  return formatUrl(urlObjOrString)\n}\n\n/**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */\nexport default function LinkComponent(\n  props: LinkProps & {\n    children: React.ReactNode\n    ref: React.Ref<HTMLAnchorElement>\n  }\n) {\n  const [linkStatus, setOptimisticLinkStatus] = useOptimistic(IDLE_LINK_STATUS)\n\n  let children: React.ReactNode\n\n  const linkInstanceRef = useRef<LinkInstance | null>(null)\n\n  const {\n    href: hrefProp,\n    as: asProp,\n    children: childrenProp,\n    prefetch: prefetchProp = null,\n    passHref,\n    replace,\n    shallow,\n    scroll,\n    onClick,\n    onMouseEnter: onMouseEnterProp,\n    onTouchStart: onTouchStartProp,\n    legacyBehavior = false,\n    onNavigate,\n    ref: forwardedRef,\n    unstable_dynamicOnHover,\n    ...restProps\n  } = props\n\n  children = childrenProp\n\n  if (\n    legacyBehavior &&\n    (typeof children === 'string' || typeof children === 'number')\n  ) {\n    children = <a>{children}</a>\n  }\n\n  const router = React.useContext(AppRouterContext)\n\n  const prefetchEnabled = prefetchProp !== false\n\n  const fetchStrategy =\n    prefetchProp !== false\n      ? getFetchStrategyFromPrefetchProp(prefetchProp)\n      : // TODO: it makes no sense to assign a fetchStrategy when prefetching is disabled.\n        FetchStrategy.PPR\n\n  if (process.env.NODE_ENV !== 'production') {\n    function createPropError(args: {\n      key: string\n      expected: string\n      actual: string\n    }) {\n      return new Error(\n        `Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` +\n          (typeof window !== 'undefined'\n            ? \"\\nOpen your browser's console to view the Component stack trace.\"\n            : '')\n      )\n    }\n\n    // TypeScript trick for type-guarding:\n    const requiredPropsGuard: Record<LinkPropsRequired, true> = {\n      href: true,\n    } as const\n    const requiredProps: LinkPropsRequired[] = Object.keys(\n      requiredPropsGuard\n    ) as LinkPropsRequired[]\n    requiredProps.forEach((key: LinkPropsRequired) => {\n      if (key === 'href') {\n        if (\n          props[key] == null ||\n          (typeof props[key] !== 'string' && typeof props[key] !== 'object')\n        ) {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key],\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n\n    // TypeScript trick for type-guarding:\n    const optionalPropsGuard: Record<LinkPropsOptional, true> = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      unstable_dynamicOnHover: true,\n      onClick: true,\n      onMouseEnter: true,\n      onTouchStart: true,\n      legacyBehavior: true,\n      onNavigate: true,\n    } as const\n    const optionalProps: LinkPropsOptional[] = Object.keys(\n      optionalPropsGuard\n    ) as LinkPropsOptional[]\n    optionalProps.forEach((key: LinkPropsOptional) => {\n      const valType = typeof props[key]\n\n      if (key === 'as') {\n        if (props[key] && valType !== 'string' && valType !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'onClick' ||\n        key === 'onMouseEnter' ||\n        key === 'onTouchStart' ||\n        key === 'onNavigate'\n      ) {\n        if (props[key] && valType !== 'function') {\n          throw createPropError({\n            key,\n            expected: '`function`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'replace' ||\n        key === 'scroll' ||\n        key === 'shallow' ||\n        key === 'passHref' ||\n        key === 'legacyBehavior' ||\n        key === 'unstable_dynamicOnHover'\n      ) {\n        if (props[key] != null && valType !== 'boolean') {\n          throw createPropError({\n            key,\n            expected: '`boolean`',\n            actual: valType,\n          })\n        }\n      } else if (key === 'prefetch') {\n        if (\n          props[key] != null &&\n          valType !== 'boolean' &&\n          props[key] !== 'auto'\n        ) {\n          throw createPropError({\n            key,\n            expected: '`boolean | \"auto\"`',\n            actual: valType,\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (props.locale) {\n      warnOnce(\n        'The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization'\n      )\n    }\n    if (!asProp) {\n      let href: string | undefined\n      if (typeof hrefProp === 'string') {\n        href = hrefProp\n      } else if (\n        typeof hrefProp === 'object' &&\n        typeof hrefProp.pathname === 'string'\n      ) {\n        href = hrefProp.pathname\n      }\n\n      if (href) {\n        const hasDynamicSegment = href\n          .split('/')\n          .some((segment) => segment.startsWith('[') && segment.endsWith(']'))\n\n        if (hasDynamicSegment) {\n          throw new Error(\n            `Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`\n          )\n        }\n      }\n    }\n  }\n\n  const { href, as } = React.useMemo(() => {\n    const resolvedHref = formatStringOrUrl(hrefProp)\n    return {\n      href: resolvedHref,\n      as: asProp ? formatStringOrUrl(asProp) : resolvedHref,\n    }\n  }, [hrefProp, asProp])\n\n  // This will return the first child, if multiple are provided it will throw an error\n  let child: any\n  if (legacyBehavior) {\n    if ((children as any)?.$$typeof === Symbol.for('react.lazy')) {\n      throw new Error(\n        `\\`<Link legacyBehavior>\\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \\`<a>\\` tag.`\n      )\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      if (onClick) {\n        console.warn(\n          `\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`\n        )\n      }\n      if (onMouseEnterProp) {\n        console.warn(\n          `\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`\n        )\n      }\n      try {\n        child = React.Children.only(children)\n      } catch (err) {\n        if (!children) {\n          throw new Error(\n            `No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`\n          )\n        }\n        throw new Error(\n          `Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` +\n            (typeof window !== 'undefined'\n              ? \" \\nOpen your browser's console to view the Component stack trace.\"\n              : '')\n        )\n      }\n    } else {\n      child = React.Children.only(children)\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if ((children as any)?.type === 'a') {\n        throw new Error(\n          'Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'\n        )\n      }\n    }\n  }\n\n  const childRef: any = legacyBehavior\n    ? child && typeof child === 'object' && child.ref\n    : forwardedRef\n\n  // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n  // mount. In the future we will also use this to keep track of all the\n  // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n  // a revalidation or refresh.\n  const observeLinkVisibilityOnMount = React.useCallback(\n    (element: HTMLAnchorElement | SVGAElement) => {\n      if (router !== null) {\n        linkInstanceRef.current = mountLinkInstance(\n          element,\n          href,\n          router,\n          fetchStrategy,\n          prefetchEnabled,\n          setOptimisticLinkStatus\n        )\n      }\n\n      return () => {\n        if (linkInstanceRef.current) {\n          unmountLinkForCurrentNavigation(linkInstanceRef.current)\n          linkInstanceRef.current = null\n        }\n        unmountPrefetchableInstance(element)\n      }\n    },\n    [prefetchEnabled, href, router, fetchStrategy, setOptimisticLinkStatus]\n  )\n\n  const mergedRef = useMergedRef(observeLinkVisibilityOnMount, childRef)\n\n  const childProps: {\n    onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n    onMouseEnter: React.MouseEventHandler<HTMLAnchorElement>\n    onClick: React.MouseEventHandler<HTMLAnchorElement>\n    href?: string\n    ref?: any\n  } = {\n    ref: mergedRef,\n    onClick(e) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!e) {\n          throw new Error(\n            `Component rendered inside next/link has to pass click event to \"onClick\" prop.`\n          )\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === 'function') {\n        onClick(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onClick === 'function'\n      ) {\n        child.props.onClick(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (e.defaultPrevented) {\n        return\n      }\n      linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate)\n    },\n    onMouseEnter(e) {\n      if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n        onMouseEnterProp(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onMouseEnter === 'function'\n      ) {\n        child.props.onMouseEnter(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n        return\n      }\n\n      const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n      onNavigationIntent(\n        e.currentTarget as HTMLAnchorElement | SVGAElement,\n        upgradeToDynamicPrefetch\n      )\n    },\n    onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START\n      ? undefined\n      : function onTouchStart(e) {\n          if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n            onTouchStartProp(e)\n          }\n\n          if (\n            legacyBehavior &&\n            child.props &&\n            typeof child.props.onTouchStart === 'function'\n          ) {\n            child.props.onTouchStart(e)\n          }\n\n          if (!router) {\n            return\n          }\n          if (!prefetchEnabled) {\n            return\n          }\n\n          const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n          onNavigationIntent(\n            e.currentTarget as HTMLAnchorElement | SVGAElement,\n            upgradeToDynamicPrefetch\n          )\n        },\n  }\n\n  // If the url is absolute, we can bypass the logic to prepend the basePath.\n  if (isAbsoluteUrl(as)) {\n    childProps.href = as\n  } else if (\n    !legacyBehavior ||\n    passHref ||\n    (child.type === 'a' && !('href' in child.props))\n  ) {\n    childProps.href = addBasePath(as)\n  }\n\n  let link: React.ReactNode\n\n  if (legacyBehavior) {\n    if (process.env.NODE_ENV === 'development') {\n      errorOnce(\n        '`legacyBehavior` is deprecated and will be removed in a future ' +\n          'release. A codemod is available to upgrade your components:\\n\\n' +\n          'npx @next/codemod@latest new-link .\\n\\n' +\n          'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components'\n      )\n    }\n    link = React.cloneElement(child, childProps)\n  } else {\n    link = (\n      <a {...restProps} {...childProps}>\n        {children}\n      </a>\n    )\n  }\n\n  return (\n    <LinkStatusContext.Provider value={linkStatus}>\n      {link}\n    </LinkStatusContext.Provider>\n  )\n}\n\nconst LinkStatusContext = createContext<\n  typeof PENDING_LINK_STATUS | typeof IDLE_LINK_STATUS\n>(IDLE_LINK_STATUS)\n\nexport const useLinkStatus = () => {\n  return useContext(LinkStatusContext)\n}\n\nfunction getFetchStrategyFromPrefetchProp(\n  prefetchProp: Exclude<LinkProps['prefetch'], undefined | false>\n): PrefetchTaskFetchStrategy {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    if (prefetchProp === true) {\n      return FetchStrategy.Full\n    }\n\n    // `null` or `\"auto\"`: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport.\n    // This will also include invalid prop values that don't match the types specified here.\n    // (although those should've been filtered out by prop validation in dev)\n    prefetchProp satisfies null | 'auto'\n    return FetchStrategy.PPR\n  } else {\n    return prefetchProp === null || prefetchProp === 'auto'\n      ? // We default to PPR, and we'll discover whether or not the route supports it with the initial prefetch.\n        FetchStrategy.PPR\n      : // In the old implementation without runtime prefetches, `prefetch={true}` forces all dynamic data to be prefetched.\n        // To preserve backwards-compatibility, anything other than `false`, `null`, or `\"auto\"` results in a full prefetch.\n        // (although invalid values should've been filtered out by prop validation in dev)\n        FetchStrategy.Full\n  }\n}\n","import type { ComponentProps } from 'react'\nimport ClientLinkComponent, { type LinkProps, useLinkStatus } from './link'\n\nexport default function LinkComponent(\n  props: ComponentProps<typeof ClientLinkComponent>\n) {\n  const isLegacyBehavior = props.legacyBehavior\n  const childIsHostComponent =\n    typeof props.children === 'string' ||\n    typeof props.children === 'number' ||\n    typeof (props.children as any)?.type === 'string'\n  const childIsClientComponent =\n    (props.children as any)?.type?.$$typeof ===\n    Symbol.for('react.client.reference')\n\n  if (isLegacyBehavior && !childIsHostComponent && !childIsClientComponent) {\n    if ((props.children as any)?.type?.$$typeof === Symbol.for('react.lazy')) {\n      console.error(\n        `Using a Lazy Component as a direct child of \\`<Link legacyBehavior>\\` from a Server Component is not supported. If you need legacyBehavior, wrap your Lazy Component in a Client Component that renders the Link's \\`<a>\\` tag.`\n      )\n    } else {\n      console.error(\n        `Using a Server Component as a direct child of \\`<Link legacyBehavior>\\` is not supported. If you need legacyBehavior, wrap your Server Component in a Client Component that renders the Link's \\`<a>\\` tag.`\n      )\n    }\n  }\n\n  return <ClientLinkComponent {...props} />\n}\n\nexport { type LinkProps, useLinkStatus }\n","/**\n * Supabase query functions for the review-agent-dashboard\n *\n * These functions fetch data from the review_contractors, review_data,\n * review_analysis, and review_articles tables populated by contractor-review-agent.\n *\n * Table naming convention:\n * - review_contractors: Discovered contractors from Google Maps\n * - review_data: Individual reviews collected for each contractor\n * - review_analysis: AI-generated analysis of reviews\n * - review_articles: AI-generated SEO articles\n */\n\nimport { createClient, createAdminClient } from './server';\nimport { unstable_cache } from 'next/cache';\nimport type {\n  DBContractor,\n  DBReview,\n  DBAnalysis,\n  DBArticle,\n  PipelineStats,\n  ContractorFilters,\n  ContractorWithStatus,\n  ArticleWithContractor,\n  AnalysisWithContractor,\n  RecentActivity,\n  ContractorDetail,\n  ArticleFilters,\n  AIUsageLog,\n  AIUsageLogWithContractor,\n  AIUsageStats,\n  AIUsageFilters,\n  SearchedCity,\n  SearchHistoryFilters,\n  DailyCostTrend,\n  ModelStats,\n  PipelineTimingStats,\n} from '../types';\n\nfunction normalizeSearchTerm(input?: string): string | null {\n  if (!input) return null;\n  const sanitized = input.replace(/[(),]/g, ' ').replace(/\\s+/g, ' ').trim();\n  return sanitized.length > 0 ? sanitized : null;\n}\n\n// =============================================================================\n// Pipeline Statistics\n// =============================================================================\n\n/**\n * Get overall pipeline statistics for the dashboard overview\n *\n * @returns Pipeline stats including counts and completion rates\n */\nexport async function getPipelineStats(): Promise<PipelineStats> {\n  const supabase = await createClient();\n\n  // Run all count queries in parallel for efficiency\n  const [\n    contractorsResult,\n    reviewsResult,\n    analysesResult,\n    articlesResult,\n  ] = await Promise.all([\n    supabase.from('review_contractors').select('*', { count: 'exact', head: true }),\n    supabase.from('review_data').select('*', { count: 'exact', head: true }),\n    supabase.from('review_analysis').select('*', { count: 'exact', head: true }),\n    supabase.from('review_articles').select('*', { count: 'exact', head: true }),\n  ]);\n\n  const contractors = contractorsResult.count || 0;\n  const reviews = reviewsResult.count || 0;\n  const analyses = analysesResult.count || 0;\n  const articles = articlesResult.count || 0;\n\n  return {\n    contractors,\n    reviews,\n    analyses,\n    articles,\n    analysisRate: contractors > 0 ? (analyses / contractors) * 100 : 0,\n    articleRate: contractors > 0 ? (articles / contractors) * 100 : 0,\n  };\n}\n\n// =============================================================================\n// Contractor Queries\n// =============================================================================\n\n/**\n * Get paginated list of contractors with their status information\n *\n * @param filters - Optional filter criteria\n * @param page - Page number (1-indexed)\n * @param limit - Items per page\n * @returns Paginated contractors with status flags\n */\nexport async function getContractors(\n  filters?: ContractorFilters,\n  page = 1,\n  limit = 20\n): Promise<{ data: ContractorWithStatus[]; total: number }> {\n  const supabase = await createClient();\n\n  // Dynamic select string construction based on filters\n  let reviewAnalysisSelect = 'review_analysis(id)';\n  let reviewArticlesSelect = 'review_articles(id)';\n\n  if (filters?.hasAnalysis) {\n    reviewAnalysisSelect = 'review_analysis!inner(id)';\n  }\n  if (filters?.hasArticle) {\n    reviewArticlesSelect = 'review_articles!inner(id)';\n  }\n\n  // Build the query with minimal contractor fields and related IDs\n  let query = supabase\n    .from('review_contractors')\n    .select(\n      `\n      id,\n      business_name,\n      rating,\n      review_count,\n      city,\n      state,\n      last_synced_at,\n      ${reviewAnalysisSelect},\n      ${reviewArticlesSelect}\n    `,\n      { count: 'exact' }\n    );\n\n  // Apply basic filters\n  if (filters?.city) {\n    query = query.ilike('city', `%${filters.city}%`);\n  }\n  if (filters?.state) {\n    query = query.eq('state', filters.state);\n  }\n  if (filters?.hasReviews) {\n    query = query.gt('review_count', 0);\n  }\n  if (filters?.minRating !== undefined) {\n    query = query.gte('rating', filters.minRating);\n  }\n  if (filters?.maxRating !== undefined) {\n    query = query.lte('rating', filters.maxRating);\n  }\n  if (filters?.search) {\n    query = query.ilike('business_name', `%${filters.search}%`);\n  }\n\n  // Apply pagination\n  const from = (page - 1) * limit;\n  const to = from + limit - 1;\n  query = query.range(from, to).order('rating', { ascending: false, nullsFirst: false });\n\n  const { data, count, error } = await query;\n\n  if (error) {\n    console.error('Error fetching contractors:', error);\n    throw error;\n  }\n\n  // Transform to ContractorWithStatus\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const contractors: ContractorWithStatus[] = (data || []).map((row: any) => {\n    // Extract contractor fields (exclude nested relations)\n    const { review_analysis, review_articles, review_count, ...contractor } = row;\n\n    return {\n      ...contractor,\n      reviewCount: review_count || 0,\n      hasAnalysis: Array.isArray(review_analysis) && review_analysis.length > 0,\n      hasArticle: Array.isArray(review_articles) && review_articles.length > 0,\n    } as ContractorWithStatus;\n  });\n\n  return {\n    data: contractors,\n    total: count || 0,\n  };\n}\n\n/**\n * Get a single contractor by ID\n *\n * @param id - Contractor UUID\n * @returns Contractor or null if not found\n */\nexport async function getContractorById(id: string): Promise<DBContractor | null> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_contractors')\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      // Row not found\n      return null;\n    }\n    console.error('Error fetching contractor:', error);\n    throw error;\n  }\n\n  return data as DBContractor;\n}\n\n/**\n * Get full contractor details including all related data\n *\n * @param id - Contractor UUID\n * @returns Full contractor detail or null if not found\n */\nexport async function getContractorDetail(id: string): Promise<ContractorDetail | null> {\n  const supabase = await createClient();\n\n  // Fetch contractor with all relations\n  const { data, error } = await supabase\n    .from('review_contractors')\n    .select(\n      `\n      *,\n      review_data(*),\n      review_analysis(*),\n      review_articles(*)\n    `\n    )\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    console.error('Error fetching contractor detail:', error);\n    throw error;\n  }\n\n  if (!data) return null;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const row = data as any;\n\n  return {\n    ...row,\n    reviews: row.review_data || [],\n    analysis: row.review_analysis?.[0] || null,\n    article: row.review_articles?.[0] || null,\n  } as ContractorDetail;\n}\n\n// =============================================================================\n// Review Queries\n// =============================================================================\n\n/**\n * Get all reviews for a specific contractor\n *\n * @param contractorId - Contractor UUID\n * @returns Array of reviews, ordered by date descending\n */\nexport async function getReviewsByContractor(contractorId: string): Promise<DBReview[]> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_data')\n    .select('*')\n    .eq('contractor_id', contractorId)\n    .order('review_date', { ascending: false, nullsFirst: false });\n\n  if (error) {\n    console.error('Error fetching reviews:', error);\n    throw error;\n  }\n\n  return (data || []) as DBReview[];\n}\n\n/**\n * Get review count by rating for a contractor (for distribution charts)\n *\n * @param contractorId - Contractor UUID\n * @returns Map of rating to count\n */\nexport async function getReviewDistribution(\n  contractorId: string\n): Promise<Record<number, number>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_data')\n    .select('rating')\n    .eq('contractor_id', contractorId);\n\n  if (error) {\n    console.error('Error fetching review distribution:', error);\n    throw error;\n  }\n\n  // Count by rating\n  const distribution: Record<number, number> = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (data || []).forEach((review: any) => {\n    const rating = Math.round(review.rating);\n    if (rating >= 1 && rating <= 5) {\n      distribution[rating]++;\n    }\n  });\n\n  return distribution;\n}\n\n// =============================================================================\n// Analysis Queries\n// =============================================================================\n\n/**\n * Get analysis for a specific contractor\n *\n * @param contractorId - Contractor UUID\n * @returns Analysis or null if none exists\n */\nexport async function getAnalysisByContractor(contractorId: string): Promise<DBAnalysis | null> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_analysis')\n    .select('*')\n    .eq('contractor_id', contractorId)\n    .order('analyzed_at', { ascending: false })\n    .limit(1)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    console.error('Error fetching analysis:', error);\n    throw error;\n  }\n\n  return data as DBAnalysis;\n}\n\n/**\n * Get all analyses with pagination\n *\n * @param page - Page number (1-indexed)\n * @param limit - Items per page\n * @returns Paginated analyses with contractor data\n */\nexport async function getAnalyses(\n  page = 1,\n  limit = 20\n): Promise<{ data: AnalysisWithContractor[]; total: number }> {\n  const supabase = await createClient();\n\n  const from = (page - 1) * limit;\n  const to = from + limit - 1;\n\n  const { data, count, error } = await supabase\n    .from('review_analysis')\n    .select(\n      `\n      *,\n      contractor:review_contractors(*)\n    `,\n      { count: 'exact' }\n    )\n    .range(from, to)\n    .order('analyzed_at', { ascending: false });\n\n  if (error) {\n    console.error('Error fetching analyses:', error);\n    throw error;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const analyses = (data || []).map((row: any) => ({\n    ...row,\n    contractor: row.contractor,\n  })) as AnalysisWithContractor[];\n\n  return {\n    data: analyses,\n    total: count || 0,\n  };\n}\n\n// =============================================================================\n// Article Queries\n// =============================================================================\n\n/**\n * Get article for a specific contractor\n *\n * @param contractorId - Contractor UUID\n * @returns Article or null if none exists\n */\nexport async function getArticleByContractor(contractorId: string): Promise<DBArticle | null> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_articles')\n    .select('*')\n    .eq('contractor_id', contractorId)\n    .order('generated_at', { ascending: false })\n    .limit(1)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    console.error('Error fetching article:', error);\n    throw error;\n  }\n\n  return data as DBArticle;\n}\n\n/**\n * Get all articles with optional filters, search, sort, and pagination\n *\n * @param filters - Optional filter/search/sort options\n * @param page - Page number (1-indexed)\n * @param limit - Items per page\n * @returns Paginated articles with contractor data\n */\nexport async function getArticles(\n  filters?: ArticleFilters,\n  page = 1,\n  limit = 20\n): Promise<{ data: ArticleWithContractor[]; total: number }> {\n  const supabase = await createClient();\n\n  const from = (page - 1) * limit;\n  const to = from + limit - 1;\n  const searchTerm = normalizeSearchTerm(filters?.search);\n\n  let query = supabase\n    .from('review_articles')\n    .select(\n      `\n      id,\n      title,\n      slug,\n      content_markdown,\n      status,\n      generated_at,\n      contractor:review_contractors(id, business_name, city, state)\n    `,\n      { count: 'exact' }\n    );\n\n  // Apply status filter\n  if (filters?.status) {\n    query = query.eq('status', filters.status);\n  }\n\n  // Apply search filter (searches title and contractor business_name)\n  if (searchTerm) {\n    query = query.or(\n      `title.ilike.%${searchTerm}%,contractor.business_name.ilike.%${searchTerm}%`\n    );\n  }\n\n  // Apply sorting\n  const sortOption = filters?.sort || 'generated_desc';\n  switch (sortOption) {\n    case 'generated_asc':\n      query = query.order('generated_at', { ascending: true });\n      break;\n    case 'title_asc':\n      query = query.order('title', { ascending: true });\n      break;\n    case 'title_desc':\n      query = query.order('title', { ascending: false });\n      break;\n    // For contractor sorting, we'll handle it post-fetch\n    case 'contractor_asc':\n    case 'contractor_desc':\n    case 'generated_desc':\n    default:\n      query = query.order('generated_at', { ascending: false });\n      break;\n  }\n\n  query = query.range(from, to);\n\n  let { data, count, error } = await query;\n\n  if (error && searchTerm) {\n    let fallbackQuery = supabase\n      .from('review_articles')\n      .select(\n        `\n        id,\n        title,\n        slug,\n        content_markdown,\n        status,\n        generated_at,\n        contractor:review_contractors(id, business_name, city, state)\n      `,\n        { count: 'exact' }\n      );\n\n    if (filters?.status) {\n      fallbackQuery = fallbackQuery.eq('status', filters.status);\n    }\n\n    fallbackQuery = fallbackQuery.ilike('title', `%${searchTerm}%`);\n\n    switch (sortOption) {\n      case 'generated_asc':\n        fallbackQuery = fallbackQuery.order('generated_at', { ascending: true });\n        break;\n      case 'title_asc':\n        fallbackQuery = fallbackQuery.order('title', { ascending: true });\n        break;\n      case 'title_desc':\n        fallbackQuery = fallbackQuery.order('title', { ascending: false });\n        break;\n      case 'contractor_asc':\n      case 'contractor_desc':\n      case 'generated_desc':\n      default:\n        fallbackQuery = fallbackQuery.order('generated_at', { ascending: false });\n        break;\n    }\n\n    fallbackQuery = fallbackQuery.range(from, to);\n\n    const fallbackResult = await fallbackQuery;\n    data = fallbackResult.data;\n    count = fallbackResult.count;\n    error = fallbackResult.error;\n  }\n\n  if (error) {\n    console.error('Error fetching articles:', error);\n    throw error;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let articles = (data || []).map((row: any) => ({\n    ...row,\n    contractor: row.contractor,\n  })) as ArticleWithContractor[];\n\n  // Post-fetch sorting for contractor name\n  if (sortOption === 'contractor_asc') {\n    articles = articles.sort((a, b) =>\n      (a.contractor?.business_name || '').localeCompare(b.contractor?.business_name || '')\n    );\n  } else if (sortOption === 'contractor_desc') {\n    articles = articles.sort((a, b) =>\n      (b.contractor?.business_name || '').localeCompare(a.contractor?.business_name || '')\n    );\n  }\n\n  return {\n    data: articles,\n    total: count || 0,\n  };\n}\n\n/**\n * Get total/published/draft counts for articles with optional search filter\n *\n * @param search - Optional search query (title or contractor name)\n * @returns Aggregate counts for articles\n */\nexport async function getArticleStatusCounts(search?: string): Promise<{\n  total: number;\n  published: number;\n  draft: number;\n}> {\n  const supabase = await createClient();\n  const searchTerm = normalizeSearchTerm(search);\n\n  const buildBaseQuery = (includeContractor: boolean) => {\n    let query = supabase\n      .from('review_articles')\n      .select(\n        includeContractor\n          ? 'id, contractor:review_contractors(id, business_name)'\n          : 'id',\n        {\n          count: 'exact',\n          head: true,\n        }\n      );\n\n    if (searchTerm) {\n      query = includeContractor\n        ? query.or(\n            `title.ilike.%${searchTerm}%,contractor.business_name.ilike.%${searchTerm}%`\n          )\n        : query.ilike('title', `%${searchTerm}%`);\n    }\n\n    return query;\n  };\n\n  const [totalResult, publishedResult, draftResult] = await Promise.all([\n    buildBaseQuery(true),\n    buildBaseQuery(true).eq('status', 'published'),\n    buildBaseQuery(true).eq('status', 'draft'),\n  ]);\n\n  if (totalResult.error || publishedResult.error || draftResult.error) {\n    if (!search) {\n      console.error('Error fetching article status counts:', {\n        total: totalResult.error,\n        published: publishedResult.error,\n        draft: draftResult.error,\n      });\n      return { total: 0, published: 0, draft: 0 };\n    }\n\n    const [fallbackTotal, fallbackPublished, fallbackDraft] = await Promise.all([\n      buildBaseQuery(false),\n      buildBaseQuery(false).eq('status', 'published'),\n      buildBaseQuery(false).eq('status', 'draft'),\n    ]);\n\n    if (\n      fallbackTotal.error ||\n      fallbackPublished.error ||\n      fallbackDraft.error\n    ) {\n      console.error('Error fetching fallback article status counts:', {\n        total: fallbackTotal.error,\n        published: fallbackPublished.error,\n        draft: fallbackDraft.error,\n      });\n      return { total: 0, published: 0, draft: 0 };\n    }\n\n    return {\n      total: fallbackTotal.count || 0,\n      published: fallbackPublished.count || 0,\n      draft: fallbackDraft.count || 0,\n    };\n  }\n\n  return {\n    total: totalResult.count || 0,\n    published: publishedResult.count || 0,\n    draft: draftResult.count || 0,\n  };\n}\n\n/**\n * Get article by ID with contractor data\n *\n * @param id - Article UUID\n * @returns Article with contractor or null if not found\n */\nexport async function getArticleById(id: string): Promise<ArticleWithContractor | null> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_articles')\n    .select(\n      `\n      id,\n      contractor_id,\n      title,\n      slug,\n      content_markdown,\n      metadata_json,\n      model_used,\n      tokens_used,\n      cost_estimate,\n      status,\n      generated_at,\n      contractor:review_contractors(id, business_name, city, state, rating, review_count)\n    `\n    )\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    console.error('Error fetching article by id:', error);\n    throw error;\n  }\n\n  // Supabase returns contractor as array, extract first element\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const row = data as any;\n  return {\n    ...row,\n    contractor: Array.isArray(row.contractor) ? row.contractor[0] : row.contractor,\n  } as ArticleWithContractor;\n}\n\n/**\n * Get article by slug for public display\n *\n * @param slug - Article URL slug\n * @returns Article with contractor or null\n */\nexport async function getArticleBySlug(slug: string): Promise<ArticleWithContractor | null> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_articles')\n    .select(\n      `\n      id,\n      contractor_id,\n      title,\n      slug,\n      content_markdown,\n      metadata_json,\n      model_used,\n      tokens_used,\n      cost_estimate,\n      status,\n      generated_at,\n      contractor:review_contractors(id, business_name, city, state, rating, review_count)\n    `\n    )\n    .eq('slug', slug)\n    .single();\n\n  if (error) {\n    if (error.code === 'PGRST116') {\n      return null;\n    }\n    console.error('Error fetching article by slug:', error);\n    throw error;\n  }\n\n  // Supabase returns contractor as array, extract first element\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const row = data as any;\n  return {\n    ...row,\n    contractor: Array.isArray(row.contractor) ? row.contractor[0] : row.contractor,\n  } as ArticleWithContractor;\n}\n\n// =============================================================================\n// Reviews Browser Query\n// =============================================================================\n\nexport interface ReviewFilters {\n  rating?: number;\n  search?: string;\n  hasOwnerResponse?: boolean;\n}\n\nexport interface ReviewWithContractor {\n  id: string;\n  contractor_id: string;\n  reviewer_name: string | null;\n  rating: number;\n  review_text: string | null;\n  review_date: string | null;\n  owner_response: string | null;\n  review_url: string | null;\n  collected_at: string;\n  contractor: {\n    id: string;\n    business_name: string;\n    city: string | null;\n    state: string | null;\n  } | null;\n}\n\n/**\n * Get all reviews with optional filters and pagination\n * For the /reviews browser page\n *\n * @param filters - Optional filter criteria\n * @param page - Page number (1-indexed)\n * @param limit - Items per page\n * @returns Paginated reviews with contractor data\n */\nexport async function getReviews(\n  filters?: ReviewFilters,\n  page = 1,\n  limit = 20\n): Promise<{ data: ReviewWithContractor[]; total: number; stats: { avgRating: number; responseRate: number } }> {\n  const supabase = await createClient();\n  const searchTerm = normalizeSearchTerm(filters?.search);\n\n  const from = (page - 1) * limit;\n  const to = from + limit - 1;\n\n  let query = supabase\n    .from('review_data')\n    .select(\n      `\n      id,\n      contractor_id,\n      reviewer_name,\n      rating,\n      review_text,\n      review_date,\n      owner_response,\n      review_url,\n      collected_at,\n      contractor:review_contractors(id, business_name, city, state)\n    `,\n      { count: 'exact' }\n    );\n\n  // Apply filters\n  if (filters?.rating) {\n    query = query.eq('rating', filters.rating);\n  }\n  if (searchTerm) {\n    query = query.or(`review_text.ilike.%${searchTerm}%,reviewer_name.ilike.%${searchTerm}%`);\n  }\n  if (filters?.hasOwnerResponse !== undefined) {\n    if (filters.hasOwnerResponse) {\n      query = query.not('owner_response', 'is', null);\n    } else {\n      query = query.is('owner_response', null);\n    }\n  }\n\n  query = query\n    .range(from, to)\n    .order('review_date', { ascending: false, nullsFirst: false });\n\n  const { data, count, error } = await query;\n\n  if (error) {\n    console.error('Error fetching reviews:', error);\n    throw error;\n  }\n\n  // Calculate stats from a separate aggregate query (for all reviews, not just current page)\n  let totalReviews = 0;\n  let sumRatings = 0;\n  let withResponse = 0;\n\n  let statsQuery = supabase\n    .from('review_data')\n    .select('avg_rating:avg(rating), total_reviews:count(*), responses:count(owner_response)');\n\n  if (filters?.rating) {\n    statsQuery = statsQuery.eq('rating', filters.rating);\n  }\n  if (searchTerm) {\n    statsQuery = statsQuery.or(`review_text.ilike.%${searchTerm}%,reviewer_name.ilike.%${searchTerm}%`);\n  }\n  if (filters?.hasOwnerResponse !== undefined) {\n    if (filters.hasOwnerResponse) {\n      statsQuery = statsQuery.not('owner_response', 'is', null);\n    } else {\n      statsQuery = statsQuery.is('owner_response', null);\n    }\n  }\n\n  const { data: statsData, error: statsError } = await statsQuery;\n\n  if (statsError || !statsData || statsData.length === 0) {\n    // Fallback to client-side aggregation if the aggregate query isn't supported\n    let fallbackQuery = supabase\n      .from('review_data')\n      .select('rating, owner_response');\n\n    if (filters?.rating) {\n      fallbackQuery = fallbackQuery.eq('rating', filters.rating);\n    }\n    if (searchTerm) {\n      fallbackQuery = fallbackQuery.or(`review_text.ilike.%${searchTerm}%,reviewer_name.ilike.%${searchTerm}%`);\n    }\n    if (filters?.hasOwnerResponse !== undefined) {\n      if (filters.hasOwnerResponse) {\n        fallbackQuery = fallbackQuery.not('owner_response', 'is', null);\n      } else {\n        fallbackQuery = fallbackQuery.is('owner_response', null);\n      }\n    }\n\n    const fallbackResult = await fallbackQuery;\n\n    const allReviews = fallbackResult.data || [];\n    totalReviews = allReviews.length;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sumRatings = allReviews.reduce((sum: number, r: any) => sum + (r.rating || 0), 0);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    withResponse = allReviews.filter((r: any) => r.owner_response).length;\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const stats = statsData[0] as any as {\n      avg_rating: number | null;\n      total_reviews: number | null;\n      responses: number | null;\n    };\n    totalReviews = stats.total_reviews || 0;\n    sumRatings = (stats.avg_rating || 0) * totalReviews;\n    withResponse = stats.responses || 0;\n  }\n\n  // Supabase returns contractor as array, transform to single object\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const reviews = (data || []).map((row: any) => ({\n    ...row,\n    contractor: Array.isArray(row.contractor) ? row.contractor[0] : row.contractor,\n  })) as ReviewWithContractor[];\n\n  return {\n    data: reviews,\n    total: count || 0,\n    stats: {\n      avgRating: totalReviews > 0 ? sumRatings / totalReviews : 0,\n      responseRate: totalReviews > 0 ? (withResponse / totalReviews) * 100 : 0,\n    },\n  };\n}\n\n// =============================================================================\n// Activity & Dashboard Queries\n// =============================================================================\n\n/**\n * Get recent activity across all entities for dashboard display\n *\n * @param limit - Number of items per category\n * @returns Recent contractors, analyses, and articles\n */\nexport async function getRecentActivity(limit = 10): Promise<RecentActivity> {\n  const supabase = await createClient();\n\n  // Fetch all recent items in parallel\n  const [contractorsResult, analysesResult, articlesResult] = await Promise.all([\n    supabase\n      .from('review_contractors')\n      .select('id, business_name, discovered_at')\n      .order('discovered_at', { ascending: false })\n      .limit(limit),\n    supabase\n      .from('review_analysis')\n      .select(\n        `\n        id,\n        analyzed_at,\n        contractor:review_contractors(id, business_name)\n      `\n      )\n      .order('analyzed_at', { ascending: false })\n      .limit(limit),\n    supabase\n      .from('review_articles')\n      .select(\n        `\n        id,\n        generated_at,\n        contractor:review_contractors(id, business_name)\n      `\n      )\n      .order('generated_at', { ascending: false })\n      .limit(limit),\n  ]);\n\n  if (contractorsResult.error) {\n    console.error('Error fetching recent contractors:', contractorsResult.error);\n  }\n  if (analysesResult.error) {\n    console.error('Error fetching recent analyses:', analysesResult.error);\n  }\n  if (articlesResult.error) {\n    console.error('Error fetching recent articles:', articlesResult.error);\n  }\n\n  return {\n    recentContractors: (contractorsResult.data || []) as DBContractor[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    recentAnalyses: (analysesResult.data || []).map((row: any) => ({\n      ...row,\n      contractor: row.contractor,\n    })) as AnalysisWithContractor[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    recentArticles: (articlesResult.data || []).map((row: any) => ({\n      ...row,\n      contractor: row.contractor,\n    })) as ArticleWithContractor[],\n  };\n}\n\n/**\n * Get unique cities for filter dropdown.\n * Uses RPC function if available (faster), falls back to client-side deduplication.\n *\n * @returns Array of unique city names\n * @see sql/001_performance_optimization.sql - get_unique_cities() RPC function\n */\nexport async function getUniqueCities(): Promise<string[]> {\n  const supabase = await createClient();\n\n  // Try RPC function first (much faster - uses SQL DISTINCT)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const { data: rpcData, error: rpcError } = await (supabase as any).rpc('get_unique_cities');\n\n  if (!rpcError && rpcData) {\n    // RPC function exists and returned data\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (rpcData as any[]).map((row: any) => row.city).filter(Boolean);\n  }\n\n  // Fallback: Manual query with client-side deduplication\n  // This path is used before the migration is applied\n  const { data, error } = await supabase\n    .from('review_contractors')\n    .select('city')\n    .order('city');\n\n  if (error) {\n    console.error('Error fetching cities:', error);\n    throw error;\n  }\n\n  // Get unique cities (client-side deduplication)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const cities = Array.from(new Set((data || []).map((row: any) => row.city)));\n  return cities.filter(Boolean) as string[];\n}\n\n/**\n * Get unique states for filter dropdown.\n * Uses RPC function if available (faster), falls back to client-side deduplication.\n *\n * @returns Array of unique state codes\n * @see sql/001_performance_optimization.sql - get_unique_states() RPC function\n */\nexport async function getUniqueStates(): Promise<string[]> {\n  const supabase = await createClient();\n\n  // Try RPC function first (much faster - uses SQL DISTINCT)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const { data: rpcData, error: rpcError } = await (supabase as any).rpc('get_unique_states');\n\n  if (!rpcError && rpcData) {\n    // RPC function exists and returned data\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (rpcData as any[]).map((row: any) => row.state).filter(Boolean);\n  }\n\n  // Fallback: Manual query with client-side deduplication\n  // This path is used before the migration is applied\n  const { data, error } = await supabase\n    .from('review_contractors')\n    .select('state')\n    .order('state');\n\n  if (error) {\n    console.error('Error fetching states:', error);\n    throw error;\n  }\n\n  // Get unique states (client-side deduplication)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const states = Array.from(new Set((data || []).map((row: any) => row.state)));\n  return states.filter(Boolean) as string[];\n}\n\n/**\n * Cached version of getUniqueCities for filter dropdowns.\n * Caches the result for 1 hour to avoid full table scans on every page load.\n *\n * Uses admin client (no cookies) to work with unstable_cache.\n * Filter options are public data so this is safe.\n *\n * Performance impact: Reduces page load from 500ms-5s to <100ms\n * by eliminating redundant queries for dropdown options.\n *\n * @returns Promise<string[]> - Array of unique city names (cached)\n */\nexport const getCachedCities = unstable_cache(\n  async () => {\n    const supabase = createAdminClient();\n\n    // Try RPC function first (much faster - uses SQL DISTINCT)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const { data: rpcData, error: rpcError } = await (supabase as any).rpc('get_unique_cities');\n\n    if (!rpcError && rpcData) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return (rpcData as any[]).map((row: any) => row.city).filter(Boolean) as string[];\n    }\n\n    // Fallback: Manual query with client-side deduplication\n    const { data, error } = await supabase\n      .from('review_contractors')\n      .select('city')\n      .order('city');\n\n    if (error) {\n      console.error('Error fetching cities:', error);\n      throw error;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const cities = Array.from(new Set((data || []).map((row: any) => row.city)));\n    return cities.filter(Boolean) as string[];\n  },\n  ['contractor-filter-cities'],\n  { revalidate: 3600, tags: ['contractor-filters'] }\n);\n\n/**\n * Cached version of getUniqueStates for filter dropdowns.\n * Caches the result for 1 hour to avoid full table scans on every page load.\n *\n * Uses admin client (no cookies) to work with unstable_cache.\n * Filter options are public data so this is safe.\n *\n * @returns Promise<string[]> - Array of unique state codes (cached)\n */\nexport const getCachedStates = unstable_cache(\n  async () => {\n    const supabase = createAdminClient();\n\n    // Try RPC function first (much faster - uses SQL DISTINCT)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const { data: rpcData, error: rpcError } = await (supabase as any).rpc('get_unique_states');\n\n    if (!rpcError && rpcData) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return (rpcData as any[]).map((row: any) => row.state).filter(Boolean) as string[];\n    }\n\n    // Fallback: Manual query with client-side deduplication\n    const { data, error } = await supabase\n      .from('review_contractors')\n      .select('state')\n      .order('state');\n\n    if (error) {\n      console.error('Error fetching states:', error);\n      throw error;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const states = Array.from(new Set((data || []).map((row: any) => row.state)));\n    return states.filter(Boolean) as string[];\n  },\n  ['contractor-filter-states'],\n  { revalidate: 3600, tags: ['contractor-filters'] }\n);\n\n// =============================================================================\n// Search Queries\n// =============================================================================\n\n/**\n * Search contractors by business name\n *\n * @param query - Search string\n * @param limit - Max results\n * @returns Matching contractors\n */\nexport async function searchContractors(\n  query: string,\n  limit = 10\n): Promise<ContractorWithStatus[]> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('review_contractors')\n    .select(\n      `\n      *,\n      review_data(id),\n      review_analysis(id),\n      review_articles(id)\n    `\n    )\n    .ilike('business_name', `%${query}%`)\n    .order('rating', { ascending: false, nullsFirst: false })\n    .limit(limit);\n\n  if (error) {\n    console.error('Error searching contractors:', error);\n    throw error;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (data || []).map((row: any) => {\n    const { review_data, review_analysis, review_articles, ...contractor } = row;\n    return {\n      ...contractor,\n      reviewCount: Array.isArray(review_data) ? review_data.length : 0,\n      hasAnalysis: Array.isArray(review_analysis) && review_analysis.length > 0,\n      hasArticle: Array.isArray(review_articles) && review_articles.length > 0,\n    } as ContractorWithStatus;\n  });\n}\n\n// =============================================================================\n// AI Usage & Cost Tracking Queries\n// =============================================================================\n\n/**\n * Get aggregated AI usage statistics\n *\n * @param filters - Optional filters (date range, operation type)\n * @returns Aggregated statistics\n */\nexport async function getAIUsageStats(filters?: AIUsageFilters): Promise<AIUsageStats> {\n  const supabase = await createClient();\n\n  let query = supabase\n    .from('ai_usage_log')\n    .select('operation, total_tokens, cost_estimate, success');\n\n  // Apply filters\n  if (filters?.operation) {\n    query = query.eq('operation', filters.operation);\n  }\n  if (filters?.success !== undefined) {\n    query = query.eq('success', filters.success);\n  }\n  if (filters?.since) {\n    query = query.gte('created_at', filters.since);\n  }\n  if (filters?.until) {\n    query = query.lte('created_at', filters.until);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error('Error fetching AI usage stats:', error);\n    // Return empty stats if table doesn't exist yet\n    return {\n      totalOperations: 0,\n      totalTokens: 0,\n      totalInputTokens: 0,\n      totalOutputTokens: 0,\n      totalCost: 0,\n      avgCostPerOperation: 0,\n      avgTokensPerOperation: 0,\n      byOperation: {\n        analyze: { count: 0, tokens: 0, inputTokens: 0, outputTokens: 0, cost: 0 },\n        generate: { count: 0, tokens: 0, inputTokens: 0, outputTokens: 0, cost: 0 },\n        discover: { count: 0, tokens: 0, inputTokens: 0, outputTokens: 0, cost: 0 },\n      },\n      successRate: 0,\n    };\n  }\n\n  const logs = (data || []) as AIUsageLog[];\n\n  // Calculate aggregations\n  const totalOperations = logs.length;\n  const totalTokens = logs.reduce((sum, log) => sum + (log.total_tokens || 0), 0);\n  const totalInputTokens = logs.reduce((sum, log) => sum + (log.input_tokens || 0), 0);\n  const totalOutputTokens = logs.reduce((sum, log) => sum + (log.output_tokens || 0), 0);\n  const totalCost = logs.reduce((sum, log) => sum + Number(log.cost_estimate || 0), 0);\n  const successfulOps = logs.filter((log) => log.success).length;\n\n  // Group by operation\n  const byOperation = {\n    analyze: { count: 0, tokens: 0, inputTokens: 0, outputTokens: 0, cost: 0 },\n    generate: { count: 0, tokens: 0, inputTokens: 0, outputTokens: 0, cost: 0 },\n    discover: { count: 0, tokens: 0, inputTokens: 0, outputTokens: 0, cost: 0 },\n  };\n\n  logs.forEach((log) => {\n    const op = log.operation as keyof typeof byOperation;\n    if (byOperation[op]) {\n      byOperation[op].count++;\n      byOperation[op].tokens += log.total_tokens || 0;\n      byOperation[op].inputTokens += log.input_tokens || 0;\n      byOperation[op].outputTokens += log.output_tokens || 0;\n      byOperation[op].cost += Number(log.cost_estimate || 0);\n    }\n  });\n\n  return {\n    totalOperations,\n    totalTokens,\n    totalInputTokens,\n    totalOutputTokens,\n    totalCost,\n    avgCostPerOperation: totalOperations > 0 ? totalCost / totalOperations : 0,\n    avgTokensPerOperation: totalOperations > 0 ? totalTokens / totalOperations : 0,\n    byOperation,\n    successRate: totalOperations > 0 ? (successfulOps / totalOperations) * 100 : 0,\n  };\n}\n\n/**\n * Get paginated AI usage logs\n *\n * @param filters - Optional filters\n * @param page - Page number (1-indexed)\n * @param limit - Items per page\n * @returns Paginated logs with contractor data\n */\nexport type LogSortColumn = 'created_at' | 'total_tokens' | 'cost_estimate' | 'duration_ms';\n\nexport async function getAIUsageLogs(\n  filters?: AIUsageFilters,\n  page = 1,\n  limit = 50,\n  sortColumn: LogSortColumn = 'created_at',\n  sortOrder: 'asc' | 'desc' = 'desc'\n): Promise<{ data: AIUsageLogWithContractor[]; total: number }> {\n  const supabase = await createClient();\n\n  const from = (page - 1) * limit;\n  const to = from + limit - 1;\n\n  let query = supabase\n    .from('ai_usage_log')\n    .select(\n      `\n      *,\n      contractor:review_contractors(id, business_name, city, state)\n    `,\n      { count: 'exact' }\n    );\n\n  // Apply filters\n  if (filters?.operation) {\n    query = query.eq('operation', filters.operation);\n  }\n  if (filters?.success !== undefined) {\n    query = query.eq('success', filters.success);\n  }\n  if (filters?.since) {\n    query = query.gte('created_at', filters.since);\n  }\n  if (filters?.until) {\n    query = query.lte('created_at', filters.until);\n  }\n\n  // Apply sorting - validate column name to prevent injection\n  const validColumns: LogSortColumn[] = ['created_at', 'total_tokens', 'cost_estimate', 'duration_ms'];\n  const safeColumn = validColumns.includes(sortColumn) ? sortColumn : 'created_at';\n\n  query = query.range(from, to).order(safeColumn, { ascending: sortOrder === 'asc' });\n\n  const { data, count, error } = await query;\n\n  if (error) {\n    console.error('Error fetching AI usage logs:', error);\n    return { data: [], total: 0 };\n  }\n\n  return {\n    data: (data || []) as AIUsageLogWithContractor[],\n    total: count || 0,\n  };\n}\n\n/**\n * Get cost breakdown by contractor\n *\n * @param contractorId - Contractor UUID\n * @returns Total cost and token usage for this contractor\n */\nexport async function getCostByContractor(contractorId: string): Promise<{\n  totalCost: number;\n  totalTokens: number;\n  operations: number;\n}> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('ai_usage_log')\n    .select('total_tokens, cost_estimate')\n    .eq('contractor_id', contractorId);\n\n  if (error) {\n    console.error('Error fetching contractor costs:', error);\n    return { totalCost: 0, totalTokens: 0, operations: 0 };\n  }\n\n  const logs = data || [];\n  return {\n    totalCost: logs.reduce((sum, log) => sum + Number(log.cost_estimate || 0), 0),\n    totalTokens: logs.reduce((sum, log) => sum + (log.total_tokens || 0), 0),\n    operations: logs.length,\n  };\n}\n\n/**\n * Get daily cost trend for the specified number of days\n *\n * @param days - Number of days to look back\n * @returns Array of daily cost data points\n */\nexport async function getDailyCostTrend(days = 30): Promise<DailyCostTrend[]> {\n  const supabase = await createClient();\n\n  const since = new Date();\n  since.setDate(since.getDate() - days);\n\n  const { data, error } = await supabase\n    .from('ai_usage_log')\n    .select('created_at, total_tokens, cost_estimate')\n    .gte('created_at', since.toISOString())\n    .order('created_at', { ascending: true });\n\n  if (error) {\n    console.error('Error fetching daily cost trend:', error);\n    return [];\n  }\n\n  // Group by date\n  const byDate: Record<string, DailyCostTrend> = {};\n\n  (data || []).forEach((log) => {\n    const date = log.created_at.split('T')[0];\n    if (!byDate[date]) {\n      byDate[date] = { date, cost: 0, tokens: 0, operations: 0 };\n    }\n    byDate[date].cost += Number(log.cost_estimate || 0);\n    byDate[date].tokens += log.total_tokens || 0;\n    byDate[date].operations++;\n  });\n\n  return Object.values(byDate).sort((a, b) => a.date.localeCompare(b.date));\n}\n\n/**\n * Get model performance statistics\n *\n * @returns Stats grouped by model\n */\nexport async function getModelStats(): Promise<ModelStats[]> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('ai_usage_log')\n    .select('model, total_tokens, cost_estimate, duration_ms, success');\n\n  if (error) {\n    console.error('Error fetching model stats:', error);\n    return [];\n  }\n\n  // Group by model\n  const byModel: Record<string, {\n    totalOps: number;\n    totalTokens: number;\n    totalCost: number;\n    totalDuration: number;\n    successCount: number;\n    durationCount: number;\n  }> = {};\n\n  (data || []).forEach((log) => {\n    const model = log.model || 'unknown';\n    if (!byModel[model]) {\n      byModel[model] = {\n        totalOps: 0,\n        totalTokens: 0,\n        totalCost: 0,\n        totalDuration: 0,\n        successCount: 0,\n        durationCount: 0,\n      };\n    }\n    byModel[model].totalOps++;\n    byModel[model].totalTokens += log.total_tokens || 0;\n    byModel[model].totalCost += Number(log.cost_estimate || 0);\n    if (log.duration_ms) {\n      byModel[model].totalDuration += log.duration_ms;\n      byModel[model].durationCount++;\n    }\n    if (log.success) {\n      byModel[model].successCount++;\n    }\n  });\n\n  return Object.entries(byModel).map(([model, stats]) => ({\n    model,\n    totalOperations: stats.totalOps,\n    totalTokens: stats.totalTokens,\n    totalCost: stats.totalCost,\n    avgDuration: stats.durationCount > 0 ? stats.totalDuration / stats.durationCount : 0,\n    successRate: stats.totalOps > 0 ? (stats.successCount / stats.totalOps) * 100 : 0,\n  }));\n}\n\n/**\n * Duration distribution buckets\n */\nexport interface DurationBucket {\n  label: string\n  min: number\n  max: number\n  count: number\n}\n\n/**\n * Get duration distribution for histogram\n *\n * @param filters - Optional filters (date range, operation type)\n * @returns Array of duration buckets with counts\n */\nexport async function getDurationDistribution(filters?: AIUsageFilters): Promise<DurationBucket[]> {\n  const supabase = await createClient();\n\n  let query = supabase\n    .from('ai_usage_log')\n    .select('duration_ms')\n    .not('duration_ms', 'is', null);\n\n  // Apply filters\n  if (filters?.operation) {\n    query = query.eq('operation', filters.operation);\n  }\n  if (filters?.success !== undefined) {\n    query = query.eq('success', filters.success);\n  }\n  if (filters?.since) {\n    query = query.gte('created_at', filters.since);\n  }\n  if (filters?.until) {\n    query = query.lte('created_at', filters.until);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error('Error fetching duration distribution:', error);\n    return [];\n  }\n\n  // Define buckets: <1s, 1-3s, 3-5s, 5-10s, 10-30s, 30s+\n  const buckets: DurationBucket[] = [\n    { label: '<1s', min: 0, max: 1000, count: 0 },\n    { label: '1-3s', min: 1000, max: 3000, count: 0 },\n    { label: '3-5s', min: 3000, max: 5000, count: 0 },\n    { label: '5-10s', min: 5000, max: 10000, count: 0 },\n    { label: '10-30s', min: 10000, max: 30000, count: 0 },\n    { label: '30s+', min: 30000, max: Infinity, count: 0 },\n  ];\n\n  // Count operations per bucket\n  (data || []).forEach((log) => {\n    const duration = log.duration_ms as number;\n    for (const bucket of buckets) {\n      if (duration >= bucket.min && duration < bucket.max) {\n        bucket.count++;\n        break;\n      }\n    }\n  });\n\n  return buckets;\n}\n\n/**\n * Get top contractors by total cost\n *\n * @param limit - Number of contractors to return\n * @returns Array of contractors sorted by total cost descending\n */\nexport async function getTopContractorsByCost(limit = 10): Promise<{\n  contractor_id: string;\n  business_name: string;\n  city: string | null;\n  state: string | null;\n  totalCost: number;\n  totalTokens: number;\n  totalOperations: number;\n}[]> {\n  const supabase = await createClient();\n\n  // Fetch all logs with contractor data\n  const { data, error } = await supabase\n    .from('ai_usage_log')\n    .select(`\n      contractor_id,\n      total_tokens,\n      cost_estimate,\n      contractor:review_contractors(id, business_name, city, state)\n    `)\n    .not('contractor_id', 'is', null);\n\n  if (error) {\n    console.error('Error fetching top contractors by cost:', error);\n    return [];\n  }\n\n  // Group by contractor\n  const byContractor: Record<string, {\n    contractor_id: string;\n    business_name: string;\n    city: string | null;\n    state: string | null;\n    totalCost: number;\n    totalTokens: number;\n    totalOperations: number;\n  }> = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (data || []).forEach((log: any) => {\n    const contractorId = log.contractor_id;\n    if (!contractorId || !log.contractor) return;\n\n    if (!byContractor[contractorId]) {\n      byContractor[contractorId] = {\n        contractor_id: contractorId,\n        business_name: log.contractor.business_name || 'Unknown',\n        city: log.contractor.city,\n        state: log.contractor.state,\n        totalCost: 0,\n        totalTokens: 0,\n        totalOperations: 0,\n      };\n    }\n\n    byContractor[contractorId].totalCost += Number(log.cost_estimate || 0);\n    byContractor[contractorId].totalTokens += log.total_tokens || 0;\n    byContractor[contractorId].totalOperations++;\n  });\n\n  // Sort by cost descending and limit\n  return Object.values(byContractor)\n    .sort((a, b) => b.totalCost - a.totalCost)\n    .slice(0, limit);\n}\n\n// =============================================================================\n// Search History Queries\n// =============================================================================\n\n/**\n * Get search history (discovery searches)\n *\n * @param filters - Optional filters\n * @param page - Page number (1-indexed)\n * @param limit - Items per page\n * @returns Paginated search history\n */\nexport type SearchSortColumn = 'searched_at' | 'contractors_found' | 'city';\n\nexport async function getSearchHistory(\n  filters?: SearchHistoryFilters,\n  page = 1,\n  limit = 50,\n  sortColumn: SearchSortColumn = 'searched_at',\n  sortOrder: 'asc' | 'desc' = 'desc'\n): Promise<{ data: SearchedCity[]; total: number }> {\n  const supabase = await createClient();\n\n  const from = (page - 1) * limit;\n  const to = from + limit - 1;\n\n  let query = supabase.from('searched_cities').select('*', { count: 'exact' });\n\n  // Apply filters\n  if (filters?.city) {\n    query = query.ilike('city', `%${filters.city}%`);\n  }\n  if (filters?.state) {\n    query = query.eq('state', filters.state);\n  }\n  if (filters?.searchTerm) {\n    query = query.ilike('search_term', `%${filters.searchTerm}%`);\n  }\n\n  // Apply sorting - validate column name\n  const validColumns: SearchSortColumn[] = ['searched_at', 'contractors_found', 'city'];\n  const safeColumn = validColumns.includes(sortColumn) ? sortColumn : 'searched_at';\n\n  query = query.range(from, to).order(safeColumn, { ascending: sortOrder === 'asc' });\n\n  const { data, count, error } = await query;\n\n  if (error) {\n    console.error('Error fetching search history:', error);\n    return { data: [], total: 0 };\n  }\n\n  return {\n    data: (data || []) as SearchedCity[],\n    total: count || 0,\n  };\n}\n\n/**\n * Get search history summary stats\n *\n * @returns Summary of searches\n */\nexport async function getSearchHistoryStats(): Promise<{\n  totalSearches: number;\n  totalContractorsFound: number;\n  uniqueCities: number;\n  uniqueStates: number;\n}> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('searched_cities')\n    .select('city, state, contractors_found');\n\n  if (error) {\n    console.error('Error fetching search history stats:', error);\n    return {\n      totalSearches: 0,\n      totalContractorsFound: 0,\n      uniqueCities: 0,\n      uniqueStates: 0,\n    };\n  }\n\n  const searches = data || [];\n  const cities = new Set(searches.map((s) => s.city));\n  const states = new Set(searches.map((s) => s.state).filter(Boolean));\n\n  return {\n    totalSearches: searches.length,\n    totalContractorsFound: searches.reduce((sum, s) => sum + (s.contractors_found || 0), 0),\n    uniqueCities: cities.size,\n    uniqueStates: states.size,\n  };\n}\n\n/**\n * Get duplicate search combos (city + search_term appearing more than once)\n *\n * @returns Set of duplicate keys (city|state|search_term)\n */\nexport async function getDuplicateSearches(): Promise<Set<string>> {\n  const supabase = await createClient();\n\n  const { data, error } = await supabase\n    .from('searched_cities')\n    .select('city, state, search_term');\n\n  if (error) {\n    console.error('Error fetching searches for duplicates:', error);\n    return new Set();\n  }\n\n  // Count occurrences\n  const counts: Record<string, number> = {};\n  (data || []).forEach((search) => {\n    const key = `${search.city}|${search.state || ''}|${search.search_term}`;\n    counts[key] = (counts[key] || 0) + 1;\n  });\n\n  // Return keys with count > 1\n  const duplicates = new Set<string>();\n  Object.entries(counts).forEach(([key, count]) => {\n    if (count > 1) {\n      duplicates.add(key);\n    }\n  });\n\n  return duplicates;\n}\n\n// =============================================================================\n// Optimized Search History Queries (Scalable)\n// =============================================================================\n\n/**\n * Scalable stats query using SQL aggregates instead of full table scan.\n * Returns stats in O(1) time with proper indexes vs O(N) for client-side.\n *\n * @param filters - Optional filters to scope stats\n * @returns Aggregated search statistics\n */\nexport async function getSearchStatsOptimized(filters?: SearchHistoryFilters): Promise<{\n  totalSearches: number;\n  totalContractorsFound: number;\n  uniqueCities: number;\n  uniqueStates: number;\n}> {\n  const supabase = await createClient();\n\n  // Build filtered query - Supabase doesn't support aggregate functions directly,\n  // so we use select with count option for total and separate DISTINCT queries\n  let query = supabase.from('searched_cities').select('*', { count: 'exact', head: true });\n\n  if (filters?.city) {\n    query = query.eq('city', filters.city);\n  }\n  if (filters?.state) {\n    query = query.eq('state', filters.state);\n  }\n\n  // Get total count\n  const { count: totalSearches, error: countError } = await query;\n\n  if (countError) {\n    console.error('Error fetching search stats:', countError);\n    return { totalSearches: 0, totalContractorsFound: 0, uniqueCities: 0, uniqueStates: 0 };\n  }\n\n  // Get sum of contractors_found and distinct counts with separate optimized queries\n  // These use DISTINCT which PostgreSQL optimizes with indexes\n  let sumQuery = supabase.from('searched_cities').select('contractors_found');\n  let cityQuery = supabase.from('searched_cities').select('city');\n  let stateQuery = supabase.from('searched_cities').select('state');\n\n  if (filters?.city) {\n    sumQuery = sumQuery.eq('city', filters.city);\n    cityQuery = cityQuery.eq('city', filters.city);\n    stateQuery = stateQuery.eq('city', filters.city);\n  }\n  if (filters?.state) {\n    sumQuery = sumQuery.eq('state', filters.state);\n    cityQuery = cityQuery.eq('state', filters.state);\n    stateQuery = stateQuery.eq('state', filters.state);\n  }\n\n  const [sumResult, cityResult, stateResult] = await Promise.all([\n    sumQuery,\n    cityQuery,\n    stateQuery,\n  ]);\n\n  // Calculate sum client-side (unavoidable without RPC, but limited by filters)\n  const totalContractorsFound = (sumResult.data || []).reduce(\n    (sum, row) => sum + (row.contractors_found || 0),\n    0\n  );\n\n  // Use Set for distinct counts (fast for filtered results)\n  const uniqueCities = new Set((cityResult.data || []).map((r) => r.city)).size;\n  const uniqueStates = new Set(\n    (stateResult.data || []).map((r) => r.state).filter(Boolean)\n  ).size;\n\n  return {\n    totalSearches: totalSearches || 0,\n    totalContractorsFound,\n    uniqueCities,\n    uniqueStates,\n  };\n}\n\n/**\n * Get global filter options for the searches page.\n * Fetches ALL distinct cities and states so filters work across pages.\n *\n * @returns Object with arrays of unique states and cities\n */\nexport async function getGlobalFilterOptions(): Promise<{\n  states: string[];\n  cities: string[];\n}> {\n  const supabase = await createClient();\n\n  // Fetch distinct values - PostgreSQL optimizes DISTINCT with indexes\n  const [statesResult, citiesResult] = await Promise.all([\n    supabase.from('searched_cities').select('state').order('state'),\n    supabase.from('searched_cities').select('city').order('city').limit(500),\n  ]);\n\n  // Extract unique values (dedupe in case of missing DISTINCT support)\n  const states = [\n    ...new Set(\n      (statesResult.data || [])\n        .map((r) => r.state)\n        .filter((s): s is string => Boolean(s))\n    ),\n  ].sort();\n\n  const cities = [\n    ...new Set((citiesResult.data || []).map((r) => r.city)),\n  ].sort();\n\n  return { states, cities };\n}\n\n/**\n * Database-optimized duplicate detection using GROUP BY HAVING.\n * Returns array of duplicate keys instead of loading entire dataset.\n *\n * Since Supabase JS client doesn't support GROUP BY HAVING directly,\n * we use a workaround: fetch grouped data and filter.\n *\n * @returns Array of duplicate \"city|state|search_term\" keys\n */\nexport async function getDuplicateKeysOptimized(): Promise<string[]> {\n  const supabase = await createClient();\n\n  // Fetch minimal data needed for duplicate detection\n  // Limit to reasonable amount for scalability\n  const { data, error } = await supabase\n    .from('searched_cities')\n    .select('city, state, search_term')\n    .limit(10000); // Safety limit\n\n  if (error) {\n    console.error('Error fetching duplicates:', error);\n    return [];\n  }\n\n  // Count occurrences efficiently\n  const counts: Record<string, number> = {};\n  for (const search of data || []) {\n    const key = `${search.city}|${search.state || ''}|${search.search_term}`;\n    counts[key] = (counts[key] || 0) + 1;\n  }\n\n  // Return only duplicate keys\n  return Object.entries(counts)\n    .filter(([, count]) => count > 1)\n    .map(([key]) => key);\n}\n\n// =============================================================================\n// Pipeline Timing Queries\n// =============================================================================\n\n/**\n * Get real pipeline timing statistics from ai_usage_log\n *\n * @returns Timing stats for each pipeline stage\n */\nexport async function getPipelineTimingStats(): Promise<PipelineTimingStats> {\n  const supabase = await createClient();\n\n  // Fetch all logs to calculate timing stats\n  const { data, error } = await supabase\n    .from('ai_usage_log')\n    .select('operation, duration_ms, created_at')\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error('Error fetching pipeline timing:', error);\n    return {\n      discover: { avgDuration: null, lastRun: null, totalRuns: 0 },\n      analyze: { avgDuration: null, lastRun: null, totalRuns: 0 },\n      generate: { avgDuration: null, lastRun: null, totalRuns: 0 },\n    };\n  }\n\n  const logs = data || [];\n\n  // Helper to calculate stats for an operation type\n  const calcStats = (operation: string) => {\n    const opLogs = logs.filter((l) => l.operation === operation);\n    const withDuration = opLogs.filter((l) => l.duration_ms);\n    const totalDuration = withDuration.reduce((sum, l) => sum + (l.duration_ms || 0), 0);\n\n    return {\n      avgDuration: withDuration.length > 0 ? Math.round(totalDuration / withDuration.length) : null,\n      lastRun: opLogs.length > 0 ? opLogs[0].created_at : null,\n      totalRuns: opLogs.length,\n    };\n  };\n\n  return {\n    discover: calcStats('discover'),\n    analyze: calcStats('analyze'),\n    generate: calcStats('generate'),\n  };\n}\n"],"names":["LinkComponent","useLinkStatus","isModifiedEvent","event","eventTarget","currentTarget","target","getAttribute","metaKey","ctrlKey","shiftKey","altKey","nativeEvent","which","linkClicked","e","href","as","linkInstanceRef","replace","scroll","onNavigate","window","nodeName","isAnchorNodeName","toUpperCase","hasAttribute","isLocalURL","preventDefault","location","isDefaultPrevented","dispatchNavigateAction","require","React","startTransition","current","formatStringOrUrl","urlObjOrString","formatUrl","props","linkStatus","setOptimisticLinkStatus","useOptimistic","IDLE_LINK_STATUS","children","useRef","hrefProp","asProp","childrenProp","prefetch","prefetchProp","passHref","shallow","onClick","onMouseEnter","onMouseEnterProp","onTouchStart","onTouchStartProp","legacyBehavior","ref","forwardedRef","unstable_dynamicOnHover","restProps","a","router","useContext","AppRouterContext","prefetchEnabled","fetchStrategy","getFetchStrategyFromPrefetchProp","FetchStrategy","PPR","process","env","NODE_ENV","createPropError","args","Error","key","expected","actual","requiredPropsGuard","requiredProps","Object","keys","forEach","_","optionalPropsGuard","optionalProps","valType","locale","warnOnce","pathname","hasDynamicSegment","split","some","segment","startsWith","endsWith","useMemo","resolvedHref","child","$$typeof","Symbol","for","console","warn","Children","only","err","type","childRef","observeLinkVisibilityOnMount","useCallback","element","mountLinkInstance","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","mergedRef","useMergedRef","childProps","defaultPrevented","upgradeToDynamicPrefetch","onNavigationIntent","__NEXT_LINK_NO_TOUCH_START","undefined","isAbsoluteUrl","addBasePath","link","errorOnce","cloneElement","LinkStatusContext","Provider","value","createContext","__NEXT_CACHE_COMPONENTS","Full","isLegacyBehavior","childIsHostComponent","childIsClientComponent","error","ClientLinkComponent"],"mappings":"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","ignoreList":[0,1,3]}